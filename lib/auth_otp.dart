library auth_otp;

import 'dart:math';
import 'dart:typed_data';
import 'package:crypto/crypto.dart';

// Auth TOTP
class AuthOTP {
  /// The secret is generated using the Base32 alphabet and is suitable for
  /// use in TOTP (Time-based One-Time Password) applications.
  ///
  /// [length] The length of the secret to generate. Must be between 16 and 32.
  /// Defaults to 32.
  static String createSecret([int length = 32]) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'; // Base32 alphabet
    if (length < 16 || length > 32) {
      throw ArgumentError(
          'Secret length must be between 16 and 32 characters.');
    }
    final rnd = Random.secure();
    return List.generate(length, (_) => chars[rnd.nextInt(chars.length)])
        .join();
  }

  /// Generates an OTP code based on the provided secret and interval.
  ///
  /// [secretKey] is the base32 encoded secret key.
  /// [interval] is the time interval in seconds, recommended to use 30 secs
  static String generateTOTPCode(
      {required String secretKey, required int interval}) {
    final time = DateTime.now().millisecondsSinceEpoch ~/ 1000 ~/ interval;
    final secretBytes = _base32Decode(secretKey);
    final timeBytes = Uint8List(8)
      ..buffer.asByteData().setInt64(0, time, Endian.big);
    final hmac = Hmac(sha1, secretBytes);
    final hash = hmac.convert(timeBytes).bytes;

    final offset = hash[hash.length - 1] & 0xf;
    final binary = ((hash[offset] & 0x7f) << 24) |
        ((hash[offset + 1] & 0xff) << 16) |
        ((hash[offset + 2] & 0xff) << 8) |
        (hash[offset + 3] & 0xff);

    final code = binary % 1000000;
    return code.toString().padLeft(6, '0');
  }

  /// Verifies a given TOTP code against a secret key.
  /// * [secretKey] : Secret key, generated by [createSecret]
  /// * [totpCode] : TOTP code from App
  /// It will return true if code is correct, otherwise false
  static bool verifyCode(
      {required String secretKey, required String totpCode}) {
    int interval = 30;
    int tolerance = 1;
    for (var i = -tolerance; i <= tolerance; i++) {
      final time =
          (DateTime.now().millisecondsSinceEpoch ~/ 1000 + i * interval) ~/
              interval;
      final generatedCode = _generateCodeAtTime(secretKey, time);
      if (generatedCode == totpCode) return true;
    }
    return false;
  }

  /// Generate TOTP code at a specific time
  /// * [secret] : Secret key, generated by [createSecret]
  /// * [time] : Time in seconds
  /// * [interval] : Time interval in seconds, default is 30 seconds
  static String _generateCodeAtTime(String secret, int time) {
    final timeBytes = Uint8List(8)
      ..buffer.asByteData().setInt64(0, time, Endian.big);
    final secretBytes = _base32Decode(secret);
    final hmac = Hmac(sha1, secretBytes);
    final hash = hmac.convert(timeBytes).bytes;

    final offset = hash[hash.length - 1] & 0xf;
    final binary = ((hash[offset] & 0x7f) << 24) |
        ((hash[offset + 1] & 0xff) << 16) |
        ((hash[offset + 2] & 0xff) << 8) |
        (hash[offset + 3] & 0xff);

    final code = binary % 1000000;
    return code.toString().padLeft(6, '0');
  }

  /// Decode base32 encoded string
  /// * [base32] : Base32 encoded string
  static List<int> _base32Decode(String base32) {
    const base32Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    final buffer = <int>[];
    var bits = 0;
    var value = 0;

    for (var char in base32.toUpperCase().codeUnits) {
      if (char == '='.codeUnitAt(0)) break;
      value = (value << 5) | base32Chars.indexOf(String.fromCharCode(char));
      bits += 5;

      if (bits >= 8) {
        buffer.add((value >> (bits - 8)) & 0xff);
        bits -= 8;
      }
    }
    return buffer;
  }

  // Generates a QR code URL for OTP authentication.
  /// * [appName] : App name
  /// * [secretKey] : Secret key
  static String getQRCodeUrl(
      {required String appName,
      required String secretKey,
      String? issuer = 'auth_otp'}) {
    return 'https://api.qrserver.com/v1/create-qr-code/?data=otpauth://totp/$appName?secret=$secretKey&issuer=$issuer';
  }
}
