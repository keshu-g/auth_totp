library auth_totp;

import 'dart:math';
import 'dart:typed_data';
import 'package:crypto/crypto.dart';

enum SecretKeyStyle { upperCase, lowerCase, upperLowerCase }

// Auth TOTP
class AuthTOTP {
  /// The secret is generated using the Base32 alphabet and is suitable for
  /// use in TOTP (Time-based One-Time Password) applications.
  ///
  /// * [length] : The length of the secret to generate. Must be between 16 and 255, Defaults is 32.
  /// * [autoPadding] : If true, it will create a secret with a letter by 4 sections, Defaults is false.
  /// * [secretKeyStyle] : SecretKeyStyle is used to set the case of the secret key. Defaults is upperCase.
  static String createSecret(
      {int length = 32,
      bool autoPadding = false,
      SecretKeyStyle secretKeyStyle = SecretKeyStyle.upperCase}) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'; // Base32 alphabet
    if (length < 16 || length > 255) {
      throw ArgumentError('The length of the secret must be 16 to 255.');
    }
    final rnd = Random.secure();
    var generatedSecret =
        List.generate(length, (_) => chars[rnd.nextInt(chars.length)]).join();
    generatedSecret =
        autoPadding ? _autoPadding(generatedSecret) : generatedSecret;

    if (secretKeyStyle == SecretKeyStyle.upperCase) {
      generatedSecret = generatedSecret.toUpperCase();
    } else if (secretKeyStyle == SecretKeyStyle.lowerCase) {
      generatedSecret = generatedSecret.toLowerCase();
    } else if (secretKeyStyle == SecretKeyStyle.upperLowerCase) {
      generatedSecret = _randomizeCase(generatedSecret);
    }
    return generatedSecret;
  }

  /// Generates an OTP code based on the provided secret and interval.
  ///
  /// * [secretKey] is the secret key in string, length limit 16 to 255.
  /// * [interval] is the time interval in seconds, recommended to use 30 secs
  static String generateTOTPCode(
      {required String secretKey, required int interval}) {
    if (secretKey.length < 16 || secretKey.length > 255) {
      throw ArgumentError('The length of the secret must be 16 to 255.');
    }
    final time = DateTime.now().millisecondsSinceEpoch ~/ 1000 ~/ interval;
    //remove space and dash
    secretKey = secretKey.replaceAll(RegExp(r'[ -]'), '');
    final secretBytes = _base32Decode(secretKey);
    final timeBytes = Uint8List(8)
      ..buffer.asByteData().setInt64(0, time, Endian.big);
    final hmac = Hmac(sha1, secretBytes);
    final hash = hmac.convert(timeBytes).bytes;

    final offset = hash[hash.length - 1] & 0xf;
    final binary = ((hash[offset] & 0x7f) << 24) |
        ((hash[offset + 1] & 0xff) << 16) |
        ((hash[offset + 2] & 0xff) << 8) |
        (hash[offset + 3] & 0xff);

    final code = binary % 1000000;
    return code.toString().padLeft(6, '0');
  }

  /// Verifies a given TOTP code against a secret key.
  /// * [secretKey] : Secret key, generated by [createSecret]
  /// * [totpCode] : TOTP code from App
  /// * [interval] : Time interval in seconds, default is 30 seconds
  /// It will return true if code is correct, otherwise false
  static bool verifyCode(
      {required String secretKey,
      required String totpCode,
      int interval = 30}) {
    secretKey = secretKey.replaceAll(RegExp(r'[ -]'), '');
    int tolerance = 1;
    for (var i = -tolerance; i <= tolerance; i++) {
      final time =
          (DateTime.now().millisecondsSinceEpoch ~/ 1000 + i * interval) ~/
              interval;
      final generatedCode = _generateCodeAtTime(secretKey, time);
      if (generatedCode == totpCode) return true;
    }
    return false;
  }

  /// Generate TOTP code at a specific time
  /// * [secret] : Secret key, generated by [createSecret]
  /// * [time] : Time in seconds
  static String _generateCodeAtTime(String secret, int time) {
    secret = secret.replaceAll(RegExp(r'[ -]'), '');
    final timeBytes = Uint8List(8)
      ..buffer.asByteData().setInt64(0, time, Endian.big);
    final secretBytes = _base32Decode(secret);
    final hmac = Hmac(sha1, secretBytes);
    final hash = hmac.convert(timeBytes).bytes;

    final offset = hash[hash.length - 1] & 0xf;
    final binary = ((hash[offset] & 0x7f) << 24) |
        ((hash[offset + 1] & 0xff) << 16) |
        ((hash[offset + 2] & 0xff) << 8) |
        (hash[offset + 3] & 0xff);

    final code = binary % 1000000;
    return code.toString().padLeft(6, '0');
  }

  /// Decode base32 encoded string
  /// * [base32] : Base32 encoded string
  static List<int> _base32Decode(String base32) {
    const base32Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    final buffer = <int>[];
    var bits = 0;
    var value = 0;

    for (var char in base32.toUpperCase().codeUnits) {
      if (char == '='.codeUnitAt(0)) break;
      value = (value << 5) | base32Chars.indexOf(String.fromCharCode(char));
      bits += 5;

      if (bits >= 8) {
        buffer.add((value >> (bits - 8)) & 0xff);
        bits -= 8;
      }
    }
    return buffer;
  }

  // Generates a QR code URL for OTP authentication.
  /// * [appName] : App name
  /// * [secretKey] : Secret key
  static String getQRCodeUrl(
      {required String appName,
      required String secretKey,
      String? issuer = 'auth_otp'}) {
    return 'https://api.qrserver.com/v1/create-qr-code/?data=otpauth://totp/$appName?secret=$secretKey&issuer=$issuer';
  }

  /// Adds spaces to the input string every 4 characters.
  ///
  /// This function takes a string as input and adds spaces to it every 4 characters.
  /// The resulting string is returned.
  ///
  /// Parameters:
  /// * [input] : The input string to be padded.
  ///
  /// Returns:
  /// - The padded string with spaces added every 4 characters.
  static String _autoPadding(String input) {
    // Create a StringBuffer to build the output string
    StringBuffer output = StringBuffer();

    // Loop through the string in steps of 4
    for (int i = 0; i < input.length; i += 4) {
      // Check if there are at least 4 characters left
      if (i + 4 <= input.length) {
        // Append the next 4 characters
        output.write(input.substring(i, i + 4));
        // Add a space if this is not the last group
        if (i + 4 < input.length) {
          output.write(' ');
        }
      }
    }

    return output.toString();
  }

  // Randomizes the case of the input string.
  ///
  /// This function takes a string as input and randomizes the case of each character in the string.
  /// The resulting string is returned.
  ///
  /// Parameters:
  /// [input] : The input string to be randomized.
  ///
  /// Returns:
  /// - The randomized string.
  static String _randomizeCase(String input) {
    final random = Random();
    StringBuffer randomizedString = StringBuffer();

    for (int i = 0; i < input.length; i++) {
      String char = input[i];
      if (random.nextBool()) {
        randomizedString.write(char.toUpperCase());
      } else {
        randomizedString.write(char.toLowerCase());
      }
    }

    return randomizedString.toString();
  }
}
